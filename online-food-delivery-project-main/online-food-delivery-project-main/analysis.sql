--phase 1 exploratory analysis
--total revenue generated by the food delivery app
use food_app_project;
SELECT SUM(order_amount-discount) AS total_revenue
FROM orders;
-- total  orders for city
SELECT city, COUNT(*) AS total_orders
FROM orders o
JOIN restaurants r ON o.restaurant_id = r.restaurant_id
GROUP BY r.city
ORDER BY total_orders DESC;

-- top 10 customer by spending
SELECT c.name, SUM(o.order_amount - o.discount) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id
ORDER BY total_spent DESC
LIMIT 10;

--phase 2: customer segmentation
-- 4.customer category (gold/silver/bronze)
-- Customer segmentation into Gold, Silver, and Bronze categories
SELECT 
    c.customer_id,
    c.name,
    SUM(o.order_amount - o.discount) AS total_spent,
    CASE 
        WHEN SUM(o.order_amount - o.discount) >= 1000 THEN 'Gold'
        WHEN SUM(o.order_amount - o.discount) BETWEEN 500 AND 999 THEN 'Silver'
        ELSE 'Bronze'
    END AS customer_category
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name
ORDER BY total_spent DESC;


--phase 3: restaurant performance analysis
-- 5. top 10 restaurants by revenue
SELECT r.restaurant_id,r.restaurant_name,r.city, SUM(o.order_amount - o.discount) AS total_revenue
FROM restaurants r
JOIN orders o ON r.restaurant_id = o.restaurant_id
GROUP BY r.restaurant_id, r.restaurant_name,r.city
ORDER BY total_revenue DESC
LIMIT 10;

--avg rating vs revenue
SELECT r.restaurant_name, r.rating, SUM(o.order_amount - o.discount) AS total_revenue
FROM restaurants r
JOIN orders o ON r.restaurant_id = o.restaurant_id
GROUP BY r.restaurant_id, r.restaurant_name, r.rating
ORDER BY total_revenue DESC;

--avg delivery time per city
SELECT r.city, AVG(o.delivery_time) AS avg_delivery_time
FROM orders o
JOIN restaurants r ON o.restaurant_id = r.restaurant_id
GROUP BY r.city
ORDER BY avg_delivery_time ASC;

-- 8 late deliveries (above 45 minutes)
SELECT o.order_id, r.restaurant_name, o.delivery_time
FROM orders o
JOIN restaurants r ON o.restaurant_id = r.restaurant_id
WHERE o.delivery_time > 45
ORDER BY o.delivery_time DESC;

--phase 5 payment and discount analysis
--9. payment method distribution
SELECT payment_method, COUNT(*) AS total_orders
FROM orders
GROUP BY payment_method
ORDER BY total_orders DESC;

--10. discount impact on revenue
SELECT 
    CASE 
        WHEN discount > 0 THEN 'With Discount'
        ELSE 'Without Discount'
    END AS discount_status,
    COUNT(*) AS total_orders,
    SUM(order_amount - discount) AS total_revenue
FROM orders
GROUP BY discount_status
ORDER BY total_revenue DESC;

--11.monthly revenue using cte
WITH MonthlyRevenue AS (
    SELECT 
        month(order_date) AS month,
        SUM(order_amount - discount) AS total_revenue
    FROM orders
    GROUP BY month
)
SELECT month, total_revenue
FROM MonthlyRevenue
ORDER BY month ASC;
--12. ranking restaurants as per the revenue
SELECT r.restaurant_name, SUM(o.order_amount - o.discount) AS total_revenue,
       RANK() OVER (ORDER BY SUM(o.order_amount - o.discount) DESC) AS revenue_rank
FROM restaurants r
JOIN orders o ON r.restaurant_id = o.restaurant_id
GROUP BY r.restaurant_id, r.restaurant_name
ORDER BY total_revenue DESC;

--13.above average revenue restaurants
WITH AvgRevenue AS (
    SELECT AVG(order_amount - discount) AS avg_revenue
    FROM orders
)
SELECT r.restaurant_name, SUM(o.order_amount - o.discount) AS total_revenue
FROM restaurants r
JOIN orders o ON r.restaurant_id = o.restaurant_id
GROUP BY r.restaurant_id, r.restaurant_name
HAVING SUM(o.order_amount - o.discount) > (SELECT avg_revenue FROM AvgRevenue)
ORDER BY total_revenue DESC;

--phase 7
--14.create revenue view
CREATE VIEW revenue_view AS
SELECT r.restaurant_id,r.restaurant_name,r.city, SUM(o.order_amount - o.discount) AS total_revenue
FROM orders o
JOIN restaurants r ON o.restaurant_id = r.restaurant_id
GROUP BY r.restaurant_id, r.restaurant_name,r.city;

--stored procedure to get top n restaurant 


CREATE PROCEDURE GetNRestaurants(IN top_n INT)
BEGIN
    SELECT restaurant_name, total_revenue
    FROM (
        SELECT restaurant_name, total_revenue,
               RANK() OVER (ORDER BY total_revenue DESC) AS ranking
        FROM revenue_view
    ) AS ranked_restaurants
    WHERE ranking <= top_n;
END;

SET @top_n = 5;
CALL GetNRestaurants(@top_n);



SELECT * FROM revenue_view;
SELECT restaurant_name, total_revenue,
       RANK() OVER (ORDER BY total_revenue DESC) AS ranking
FROM revenue_view;


--phase 8: performance optimization
--index on order_date(for monthly report)
CREATE INDEX idx_order_date ON orders(order_date);
--index on restaurant_name
CREATE INDEX idx_restaurant_name ON restaurants(restaurant_name);

--index on customer_name for join optimization
CREATE INDEX idex_customer_name ON customers(customer_name);

SHOW INDEX FROM restaurants;
SHOW INDEX FROM orders;
SHOW INDEX FROM customers;


--phase 9:
--auto log high value order
create table high_value_orders_log
(
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    customer_id INT,
    restaurant_id INT,
    order_amount DECIMAL(10,2),
    log_date datetime DEFAULT CURRENT_TIMESTAMP
);


create trigger log_high_value_orders
after insert on orders
for each row
begin
    if new.order_amount > 100 then
        insert into high_value_orders_log (order_id, customer_id, restaurant_id, order_amount)
        values (new.order_id, new.customer_id, new.restaurant_id, new.order_amount);
    end if;
end;

insert into orders values(1010, 231, 138, '2024-01-01', 150.00, 10.00, 'Credit Card', 30);

--create trigger to prevent negative discount
create trigger prevent_negative_discount
before insert on orders
for each row
begin
    if new.discount < 0 then
        set new.discount = 0;
    end if;
end;

insert into orders values(1014, 231, 138, '2024-01-02', 50.00, -5.00, 'Cash', 25);
select * from orders where order_id = 1014;

use food_app_project;
--delivery delay warning
create table delivery_delay_log
(
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    customer_id INT,
    restaurant_id INT,
    delivery_time INT,
    created_at datetime DEFAULT CURRENT_TIMESTAMP
);

create trigger log_delivery_delay
after insert on orders
for each row
begin
    if new.delivery_time > 45 then
        insert into delivery_delay_log (order_id, customer_id, restaurant_id, delivery_time)
        values (new.order_id, new.customer_id, new.restaurant_id, new.delivery_time);
    end if;
end;

insert into orders values(1016, 231, 138, '2024-01-03', 80.00, 5.00, 'Credit Card', 55);
